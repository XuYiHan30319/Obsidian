并发的程序通常都需要共享资源和计算资源,如果不加以控制,就会导致死锁的出现.
Mutual exclusion(互斥)就是保证两个进程(线程)无法同时访问一个资源.
# synchronization同步
我们需要避免死锁与饥饿(一些程序永不执行)
- 保证互斥
- 有空让进(deadlock-free)
- 有限等待(starvation-free)

## 两个进程间的同步
![[Pasted image 20231227092626.png]]
turn指使了是谁的执行,flag表示是否准备进入执行区
但是软件的实现会造成忙等,最好的方式是阻塞
硬件方法:
- 关闭中断,这样就无法被打断了,不会死锁
- 原子指令

假设我们有如下的原子指令
```c++
bool TestAndSet(bool *target){
	bool rv = *target;
	*target = true;
	return rv
}
```
在之后,
```c++
bool flag = false;
while(TestAndSet(&flag));
...
flag = false;
```
或者有
```c++
void
```