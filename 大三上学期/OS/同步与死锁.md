并发的程序通常都需要共享资源和计算资源,如果不加以控制,就会导致死锁的出现.
Mutual exclusion(互斥)就是保证两个进程(线程)无法同时访问一个资源.
# synchronization同步
我们需要避免死锁与饥饿(一些程序永不执行)
- 保证互斥
- 有空让进(deadlock-free)
- 有限等待(starvation-free)

## 两个进程间的同步
![[Pasted image 20231227092626.png]]
turn指使了是谁的执行,flag表示是否准备进入执行区
但是软件的实现会造成忙等,最好的方式是阻塞
硬件方法:
- 关闭中断,这样就无法被打断了,不会死锁
- 原子指令

假设我们有如下的原子指令
```c++
bool TestAndSet(bool *target){
	bool rv = *target;
	*target = true;
	return rv
}
```
在之后,
```c++
bool flag = false;
while(TestAndSet(&flag));
...
flag = false;
```
或者有这样的原子指令
```c++
void swap(bool *a,bool *b){
	bool temp = *a;
	*a = *b;
	*b = temp;
}

bool flag = false;
do{
	key = true;
	while(key){
		swap(lock,key);
	}
	
	...
	locak = false;
}
```
## 信号量semaphore
信号量是通过两个原子指令实现的
- wait(s)/P(s)
- signal(s)/V(s)

wait(mutex);
do;
singal(mutex);
使用信号量可以控制进程执行顺序
![[Pasted image 20231227094818.png]]
多个信号量的代码实现
![[Pasted image 20231227094843.png]]
# 死锁
## 死锁的4个必要条件
- 互斥Mutual Exclusion
- Hold and wait占有并等待
- No preemption非抢占
- Circular wait循环等待


## 互斥方法:给很多很多资源
如果有n个process,each process need x resources,than the least number of resources is $(x-1)*n+1$(注意这里加了1)
## 占有并等待
- 一次全部申请到,就不会发送死锁了
	- 但是可能会导致不高效,所有的资源也不是一次就确定完的,还有可能会发生starvation
- 当需要申请资源的时候,如果资源不够就释放全部的已有资源,或者每次请求前都释放所有的
## 循环等待
![[Pasted image 20231227203313.png]]
优先提供给低等级的进程,这样就能够保证没有圈圈并且低等级的能够执行

## 考点
另一种方式就是看能不能在现有的资源中找到一种方式可以执行完所有的程序,比如下面的这段代码,我们可以p3->
![[Pasted image 20231227203533.png]]
