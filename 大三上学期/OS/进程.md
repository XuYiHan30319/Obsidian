![[Pasted image 20231226231016.png]]
进程(Process)的状态
- new
- ready
- run
- waiting
- kill

使用PCB(process control block)进行管理进程的状态,比如PID,location,调度信息等
使用swap技术把不需要的进程移到磁盘,
## 进程调度
![[Pasted image 20231226232900.png]]
![[Pasted image 20231226232730.png]]
三种调度程序:
- 长期调度:将任务放入准备队列
- 中期调度:把任务swap掉
- 短期调度:选择一个任务执行

### 进程间通信
- 共享内存![[Pasted image 20231226233523.png]]
- 消息传递

## Context Switching
进程切换的几个步骤
1. 将正在运行的程序停止
2. 将正在运行的程序的所有内容暂时保存起来
3. 加载新的程序的所有内容

## 线程(Thread)
为了让一个进程多多的干活,就有了线程的概念.当一个进程执行的时候,多个线程同时干活

# 进程调度算法
受IO运行速度限制,如果CPU同时处理IO与任务队列就很缓慢.我们把进程的执行分为CPU Burst和IO Brust
## 评估调度算法的效果的指标
- CPU utilization|CPU使用率
- throughput吞吐量(单位时间完成的任务数)
- Turnaround time周转时间(一个任务的完成时间)
- Waiting time
- Resonse time任务创建到执行的时间开销

## 抢占式调度与非抢占式调度
- Non-preemptive
	- 不能被其他任务打断,直到执行完毕
- preemptice
	- 当前执行的任务可能会被其他的任务打断并移入等待队列

### 先来先服务
![[Pasted image 20231226235417.png]]
缺点:
- Convoy Effect(护航效果):短的任务得等长的执行
- 不利于IO密集的任务

### 最短优先
最短的先执行(SJN),这是一种理想化的最优算法
![[Pasted image 20231226235747.png]]
缺点:
- 我们需要对CPU的执行时间预测,average为平均cpu时间,predict为预测时间,α为比例,下一个时间就是αaverage+(1-α)predict
- 可能会出现饥饿(starvation),长的任务可能一直拍不到 

###  最短剩余时间任务SRJF
可打断的
![[Pasted image 20231227000158.png]]
### 优先级
优先级越小越优先优先,是非抢占的
![[Pasted image 20231227000333.png]]
优先级调度可能也会出现starvation的现象,可以使用Aging方法,让越久的任务优先级越高
### Round-Robing 轮询
轮询,打断
使用一个队列任务执行,<font color="#ff0000">刚到达的先放入队列,然后再把刚刚执行完的放进去</font>.
可以进化为多等级的队列
![[Pasted image 20231227090640.png]]
优先级越低的越先执行.
![[Pasted image 20231227090839.png]]
首先abc都进过priority0让任务-1,然后假设a被阻塞,则a的优先级提升,然后b执行
![[Pasted image 20231227090921.png]]
![[Pasted image 20231227090946.png]]
然后再做a和c