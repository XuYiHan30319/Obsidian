# 函数模板

[toc]

## template\<class T\>

我们可以设置函数模板函数

```c++
template<class T>
void swapVal(T &a,T&b);...
```



模板函数如果不能满足要求,可以自己再定一个新的用于替换

在存在了swapVal(T)外,可以自己定义一个swapVal(int)

如果有了同名的具体实现函数,那么模板不会生成

在编译的时候,模板函数会自己生成一个实现具体类型的代码

## 具体实现

<img src="/Users/blackcat/Documents/北交大软件学院许一涵学习资料/大三上学期/c++/函数模板.assets/image-20231222170852966.png" alt="image-20231222170852966" style="zoom:50%;" />

↑这样是错的,虽然单独编译都没有问题,但是一起的时候会就发现swap.cpp中的内容无法找到具体的实现函数,没办法生成具体的代码,需要把通用类型编译成实际类型,所以要把函数定义放到.h文件里面去,这样就可以不报错了.也可以只在头文件里面放定义



## 模板类

```c++
template<class T>
class k{
	...
};

template<class T>
void k<T>::show(){
  
}
```

## 智能指针

```c++
#include<memory>
auto_ptr<string> ptr(new string);
```

类似于``string s("114514");shared_ptr<string> ptr_s(&s);``这样的代码需要避免,因为s是一个在栈区的函数,无法调用delete,所以程序会爆错

![image-20231228084751630](/Users/blackcat/Documents/北交大软件学院许一涵学习资料/大三上学期/c++/函数模板.assets/image-20231228084751630.png)因为智能指针的构造函数都是explicit的,所以无法从一个普通指针转换为智能

auto_ptr就跟rust的所有权一样,会失去所有权!而auto_ptr的替代品unique_ptr就是跟rust一样会在编译的时候报错.

unique_ptr只有在原ptr为暂时的右值的时候被允许

```c++
unique_ptr<string> s("123");
unique_ptr<string> s2 = unique_ptr<string>("123");
s = s2;//不允许!

```

此外,unique_ptr还可以用

```c++
unique_ptr<double[]>pda(new double(5)); // will use delete []
```

来声明一个数组