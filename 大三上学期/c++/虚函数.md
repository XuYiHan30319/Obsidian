# 虚函数

派生类定义基类方法,使用指针,公有继承,并且是虚函数，只需要这三点就可以实现虚函数，符合这三点就可实现多态
#
基类引用实际使用的是基类指针

其中多态的底层实现原理如下：

<img src="/Users/blackcat/Documents/北交大软件学院许一涵学习资料/大三上学期/c++/虚函数.assets/image-20231124174149813.png" alt="image-20231124174149813" style="zoom:50%;" />

基类指针指向了派生类对象，运行时发现了函数前面加了virtual，那么就会跳转到

```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class fruit
{
private:
public:
    fruit() = default;
    virtual void printSelf() // 虚函数,使用这样就可以进行重载,只需要在声明的地方加就可以了
    {
        // 编译器实现一个虚函数表,如果类包含了虚函数,会给这个类和他的派生类产生虚函数表
        // 会给这些类的对象加一个成员*____ptr,指向虚函数表,虚函数表存放那个虚函数的指针
        // 如果基类没重写虚函数,那么指向基类的指针
        cout << "fruit" << endl;
    }
};

class banana : public fruit
{
public:
    int color;
    banana() = default;
    // 这里如果父类不加virtual那么就是一个overriding,这里最好也加上virtual,保证你的继承也是一个虚函数
    virtual void printSelf()
    {
        cout << "banana" << endl;
    }
};

// 派生类定义基类方法,使用指针,公有继承,并且是虚函数
void kksk(fruit &fr)
{
    // 基类指针只能访问基类的方法,所以不加virtual的情况下只能访问到 fruit::banana
    fr.printSelf();
}

int main()
{
    fruit ss;
    banana kk;
    vector<fruit *> fruits;

    fruit *sss = &kk; // 这里知道sss是一个基类指针
    kksk(kk);//早绑定
    sss->printSelf(); // 这里是goto语句,跳转到banana::printself,叫做编译器的绑定(早绑定)
    kksk(ss);
    cout << sizeof(ss) << " " << sizeof(kk) << endl;
}
```

注意，虽然虚函数很好用，但是会保存一个表，导致在内存和速度上的开销很大。



## 虚析构函数

```c++
car *c = new SUV();
delete c;//这里只会删除父类的析构函数，而不会删除整个析构函数,因此我们需要设置一个虚的析构函数
//析构函数一般都是虚函数
```



## 纯虚函数

如果一个虚函数后面跟了个=0，那么就是一个纯虚函数，不需要函数体``virtual void s()=0``

一个类如果包含一个纯虚函数，那么就是一个抽象基类，不可以创建对象

