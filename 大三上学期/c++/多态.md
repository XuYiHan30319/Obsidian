# 多态

[toc]

使用多态可以对同一个方法使用不同的操作

- 重新定义父类的方法
- 使用virtual关键字
- 使用基类的指针或者引用
- 公有继承

```c++
class Car{
	public:
  	virtual void Print(){cout<<"car"<<endl;}
}

class SUV:public Car{
  public:
  	virtual void Print(){cout<<"SUV"<<endl;}
}
```

基类指针可以指向子类

SUV mySUV;

Car *carPtr = &mySUV;

> 当然反过来不行，不过可以强制类型转换，就是有点不安全



vector<Car*>rentalList,这个数组里面可以存Car和他的子类们

## 早绑定和晚绑定

晚绑定只有在程序运行的时候才会绑定，只有使用virtual才可以进行晚绑定。

virtual关键字只需要在定义的时候加就可以了。并且他的子类的对应方法不需要加(但是推荐加上,方便子类的子类继承）。

```c++
class Abstract{//Base class
public:
	void show(){cout<<"ShowAbstract \n";};
	~Abstract(){cout<<"DeAbstract\n";}
};
class Concrete: public Abstract{//Derived class
public:
	void show(){cout<<"ShowConcrete\n";}
	~Concrete(){cout<<"DeConcrete\n";}
};
int main()
{  
   Abstract *p=new Concrete;//p指向concrete内的基类
   p->show();
	 delete p;//释放p所指向的内容
   return 0; 
}
```

<img src="/Users/blackcat/Documents/北交大软件学院许一涵学习资料/大三上学期/c++/多态.assets/image-20231201164603973.png" alt="image-20231201164603973" style="zoom: 33%;" />

```c++
class Abstract{//Base class
public:
	virtual void show(){cout<<"ShowAbstract \n";};
	virtual ~Abstract(){cout<<"DeAbstract\n";}
};
class Concrete: public Abstract{//Derived class
public:
	void show(){cout<<"ShowConcrete\n";}
	~Concrete(){cout<<"DeConcrete\n";}
};
int main()
{  
   Abstract *p=new Concrete;
   p->show();
	 delete p;
   return 0; 
}
```

这里先调用子类的析构再调用父类的析构函数





