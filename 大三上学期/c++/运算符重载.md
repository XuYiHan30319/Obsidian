# 运算符重载

[toc]



Returntype operatorOP(argument)

```c++
class Time{
private:
  	int hour,minutes;
public:
  	Time Sum(const Time&t)const;//旧的
  	Time operator+(const Time&t)const;//新的
  friend Time operator+(const Time&t1,const Time&t2);//成员方法和非成员方法皆可,并且使用上无区别
}

Time Time::operator+(const Time &t) const
{
		Time sum;
  	...
    return Time();
}
time1+time2 == time1.operator+(time2)
```

不可以重载非用户定义的变量的符号



重载前置++和后置++

class &operator++()//前置

class operator++(int)//后置,返回递增前的

## 输入输出流的重载

ostream & operator<<(ostream &,class);





## 类型转换

c++的类之间可以类型转换,任何只接受一个参数的构造函数是转换构造函数

```c++
class kk{
	kk(double ls);
  kk(double ls,int a=0)；//也可以！
}
kk s = 12;//可行的

```

在上面的代码中，首先12使用kk(12)生成一个临时变量，然后再传给s

当然，如果还定义了一个kk(int)，那么kk s=12就会报错；因为失效了

```c++
class kk
{
public:
    kk(double s){

    };
   explicit kk(int s){};
    kk(long s){};
};

int main()
{
    kk s = 1;
}
```

比如这里，会匹配到int的，但是如果注释凋int，就会报错，因为到double和long都是一次转换，所以没有更好的匹配。当然如果不想要强制转换，可以使用explicit关键字关闭。



我们还可以从kk转换为int

```c++
class kk
{
public:
    kk(double s){

    };
    kk(long s){};
  	operator double() const{//不需要返回值	
      return 1.2;
    }
};

```





> 注意，同时有operator int()和construct(int)还有operator+会导致冲突！

```c++
class kk{
  operator int(){return 1;}
  kk(int a){};
  friend kk operator+(kk a,kk b);
}

k1 = k2+1;//无法确定用int的+还是kk的+
```

