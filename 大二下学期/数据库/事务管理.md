并行:多个cpu跑多个任务
并发:一个cpu跑多个任务
可串行化:并发跑完和串行跑完一样
# transaction事务
事务是指应用或者用户来执行的一个或者一系列动作
## 事务的4大特征
原子性Atomicity:要么全成功要么全失败
一致性Consistency:
隔离性Isolation:一个没有完成的事务所做的部分修改对另一个事物来说不可见,其他事物不能读取另一个事物的中间的结果
持久性Durability:提交的事务的结果永久保存,比如提交之后没写入磁盘,再次打开的时候会通过日志重新写入
# 并发控制
更新丢失
读脏数据(读到了回退前的数据)
不可重复度(一个数据毒两次不一样,读的时候有另外的数据做了改变)
幻读(两次之间有人插入了好多数据)
## 一组并发事务如何执行
锁:1.读锁(共享锁)S  加了读锁别人也只能加读锁,只能读
	2.写锁(排态锁)X 加了写锁别人啥都不能加,既能读又能写
	
一级封锁协议:写的时候加X锁,到事务结束释放
二级封锁协议:读的时候加S,读完释放
三级封锁协议:读的时候加S,事务结束释放
![[Pasted image 20230511085119.png]]
共享锁可以有多个,但是排态锁只能有一个
## 两段锁
操作分为两个阶段,第一步先把对象要的锁全部得到,但是不能释放锁,叫做扩张阶段,第二个叫收缩阶段,只能释放锁不能获得锁.
只要遵循两段锁协议,那么操作并发调度一定是可串行化的,是充分条件而不是必要条件,只要和某一种并发操作得到的结果一样就可以了

# 日志文件
日誌有几个队列,比如undo,redo队列
日志文件会给自己做镜像,就是给自己拷贝一份一模一样的,防止这个数据文件丢失.当写入进程向日志写入的时候,会自动向镜像文件写入.当一个日志文件写满了,会自动切换另一个日志.当全部写满了就回到第一个日志文件.
数据库可以有两种运行方式:归档方式(当文件全部写满了会切换日志文件,然后把原来的日志拷贝到其他的介质上叫做归档文件,能恢复到失败这一刻)和非归档方式(就是上面所说的覆盖写,不存储,只能恢复到上一次备份)

# 系统故障
1. 事务故障:程序能自己做,可以自动回复
2. 系统故障:掉电或者操作系统炸了或者内存溢出,可以自动回复,只会影响当前操作的数据,之前的不会存在,比如缓存区和内存的数据都没有了.再次重启的时候把所有commit的数据重做,没有commit的撤销,称为软故障
3. 介质故障:硬盘炸了,使用备份恢复,硬故障
4. 计算机病毒:人工使用备份恢复

反正数据库恢复就是使用冗余数据(备份和日志)来进行恢复
## 备份的几种模式
静态备份,动态备份,海量转储(全部备份一次)和增量转储(就备份修改了的表)
脱机备份(静态,数据库关闭的情况下拷贝)和联机(动态,一边做一边拷贝)备份
物理备份:把文件拷一份
逻辑备份:把逻辑对象比如表空间拷贝一份
日志优先写原则
当commit做完的时候,会把Database buffer和log buffer全部清空再提示commit做完了,先写日志再写数据库.当事务全部写完了才算结束.
检查点技术:checkpoint之前的就不需要redo,checkpoint之后的就要做,checkpoint list和redo list共同操作 
redo正着做,undo反着做
