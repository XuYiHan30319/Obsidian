Normalization
# 什么是标准化
为了为关系数据库创建一个精确的数据/关系以及限制的展示,所以我们需要定义一系列合适关系
标准化的分级:UNF-1NF-2NF-3NF-BCNF
![[Pasted image 20230425134810.png]]
各级标准化从小到大依次包含
我们可以根据属性之间的依赖来划分标准化等级,一个标准化的数据库能够防止更新异常和减少一定的数据冗余
更新异常:如果两个表都有相同字段,那么修改一个,另一个不改变,就是一种更新异常
# 函数依赖
如果B函数依赖于A,那么对于每个A,都有唯一一个B和他对应,记为(A->B)
比如学号课程决定成绩,那么一个学号课程只能对应一个成绩,但是一个成绩能对应多个学号课程
通过标准化,能够消除更新异常
## 求属性集闭包算法
![[Pasted image 20230425135800.png]]
比如求A的闭包,首先把他自己放进来,然后去看有没有以A开头的依赖,比如这里有A->B,那么就把AB放进来,再看有没有以AB或者B开头的,没有,那就结束
## 函数依赖集等价
如果两个含数据的闭包一样,那么我们就称这两个函数依赖集等价
## 最小依赖集
1. F中任意函数依赖的右部仅有一个属性
2. F中不存在这样的函数依赖x->a,使得F与F-{x->a}等价
3. 不存在函数依赖X->A,X有真子集Z,使得F-{x->a}U{Z->A}与F等价
人话来说,就是找不到一个更小的能够依赖的

比如已经有了sno->grade ,那么(sno,sname)->grade就不是最小依赖集

# UNF
就是不满足每个元素不可再分的数据表,比如一个表包含了两个及以上的字段
# 1NF
满足每个元素不可再分的表就是1NF
想要把UNF转为1NF也很简单,第一种方法,填充
![[Pasted image 20230425135157.png]]
![[Pasted image 20230425135225.png]]
第二种方法,分为两个表然后用外键
# 2NF
相较于1NF,消除了部分函数依赖
根据完全函数依赖的概念,在第二范式中,每个非主属性都必须完全函数依赖于主键(不能依赖于候选键的一部分),这里的主属性是学号和身份证号
比如我们有如下表:(学号,身份证号,姓名),(学号->姓名),(身份证号->姓名),所以姓名部分函数依赖于(学号,身份证号),只有一个主键那么一定是完全函数依赖
如何把1范式转换为2范式?
![[Pasted image 20230429102227.png]]
如图,{歌曲编号,歌手}作为候选键,而经纪公司只依赖于歌手,所以是部分函数依赖,所以要拆分表
比如拆成
![[Pasted image 20230429102519.png]]

# 3NF
表中所有数据元素不仅要唯一被主关键字标识,还必须相互独立,不存在其他函数依赖,也就是2NF上消除传递函数依赖(A->b->c,A->c)
如果存在传递函数依赖就用一个新的表代替

# BCNF
1.所有非主属性对每一个码都是[完全函数依赖](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96)。
2.所有的[主属性](https://baike.baidu.com/item/%E4%B8%BB%E5%B1%9E%E6%80%A7)对每一个不包含它的码,也是完全函数依赖。
3.没有任何属性完全函数依赖于非码的任何一组属性。
相较于3NF,3NF的函数依赖A->B允许B是候选键,A
不存在主键对于候选码的部分依赖和传递依赖
