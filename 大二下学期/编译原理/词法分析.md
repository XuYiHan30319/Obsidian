# 设计扫描器时应该考虑的问题
1. 功能:输入符号串形式的源程序 输出单词符号串
2. 实现方式:
	1. 词法分析作为单独的一遍,特点是大部分编译时间花在扫描字符上,独立出来以便集中处理,单词的词法规则简单,可建立特别适用于这种文法的有效技术,实现词法分析的自动生成,编译程序结构简单,但是产生中间文件
	2. 词法分析作为一个独立的子程序,无中间文件,编译效率高.
## 预处理
可构造与处理子程序(输入缓冲区)
1. 作用:消除无用空白,回车,注释行,区分标号区,宏替换
2. 功能:在输入缓冲区内处理出确定长的字符串放入扫描缓冲区
## 扫描缓冲区的结构
两个半区,两个指示区互补使用(现在基本已经弃用了)
## 单词符号的内部表示
### 单词符号的种类
1. 保留字,比如if,while,do等
2. 标识符:用户定义的变量,函数(保留字和标识符的识别是同步执行的)
3. 无符号整数
4. 单字符分界符,比如+-/,;等等
5. 双字符分界符://,++,--;
### 单词符号的表示类型-二元式
二元式:(单词类型,单词自身值)
1. 单词类别:说明单词属于哪一类,一般用整数编码(枚举类型)
2. 单词自身值:一种类只有一个单词,不比给出自身值,否则就必须给出单词自身值予以区别

一般保留字,运算符和分界符一符一种,不需要自身值
标识符作为一种类型,其单词自身值采用自身的字符串编码表示
常数用自己的二进制形式表示
## 标识符的若干约定和策略
### 约定
1. 标识符字符超过了最大允许长度,截取尾部
2. 不超过最大长度的标识符,则按尽可能长的原则匹配

### 单词符号超前搜索
所谓的超前搜索,就是先去后面探探路看看有没有新的字符
比如判别a>3 和a>=3,比如读到>号.我们向后再多读一个,发现是>=号,于是我们取>=符号

# 正则文法和状态转换图
![[Pasted image 20230328161117.png]]
## 由正则文法构造状态转换图
状态图由一个正则文法确定的有限的方向图,有一个初始状态和若干个终止状态
右线性:
文法的每一个非终结符号表示一个节点/开始符号也是一个节点
文法的开始符号S作为初始状态,设一个符号F不属于V作为终止状态
是一种推导过程
![[Pasted image 20230328161238.png]]
😩
左线性:
反过来,S作为终态,F作为初态,是一种最左规约过程(从后往前)![[Pasted image 20230328161425.png]]
我们将初始状态作为终态,再定义一个新的非终结符号作为初始状态
## 状态转换图的一种实现
我们使用状态转换矩阵来表示状态转换图,即二维表![[Pasted image 20230328161836.png]]
## 无符号表示的数状态图的简化
![[Pasted image 20230402144533.png]]
![[Pasted image 20230402144550.png]]
通过分析,我们可以发现,如果把1,2,6都作为一个新的终点,我们就可以省略掉F节点.
![[Pasted image 20230402144648.png]]
## 左右线性文法转换图的转换
###  右转左
![[Pasted image 20230402144906.png]]
我们添加一个新的开始节点,通过空连接到起始节点,然后就可以直接推得
### 左转右
同理,我们只需要在终结节点后面再加一个起始节点,![[Pasted image 20230402145210.png]]

# 有限自动机
## 确定自动机DFAM
由5个元素组成M=(K,E,f,s,z)
k表示k个状态
E:允许输入的字符的集合,比如只能输入ab
f:状态转换函数,单值函数K\*E ->K,,相当于离散的函数
s:初始状态,s∈k
z:终止状态集合,z∈k
### 特点
1. 确定性:
2. 有限性:k有限

推广f:f套f
### 有限自动机功能
识别句子:![[Pasted image 20230402092519.png]]
上面的特别表示他啥都没干也对

## 不确定自动机NFAM'
不确定自动机的定义是一样的,但是函数是一对多的映射,也就是一个函数能够生成好多状态
![[Pasted image 20230402093617.png]]
![[Pasted image 20230402094050.png]]
## DFAM和NFAM的等价性
![[Pasted image 20230402145846.png]]
如图,我们首先把s0放入其中,然后根据他能读的值推导出下一个状态,然后把下一个状态放进来,继续推导(集合中的每一个都算一遍然后形成一个大集合),直到推导不出新的结果为止,我们将这些q0,q1集合当做新的节点如此我们就把他从不确定转换为确定.从而证明不确定和确定是等价的
## 读空动作的NFAM确定化
如果要求一个状态q的闭包e_closure(q),我们首先把q放入这个闭包中,然后将能通过空达到的状态全部放入,就是一个他的闭包.状态集的闭包就是状态的闭包的集合
![[Pasted image 20230402150448.png]]
比如这里,我们首先把s0放进来,然后通过e走到了s1,s3,s2并且放入闭包
![[Pasted image 20230402150639.png]]
如图,我们先把q0的空闭包放进来, 然后计算出下一个状态集合以及对应的闭包,然后把下一个闭包当做新的节点状态
## DFA状态数最小化
1. 我们要将等价的状态合并,也就是两者有同样的文法的状态![[Pasted image 20230402151138.png]]
2. 可区别的(不等价):终态和非终态是可区别的终态可以读空到终态而非终态不可以

方法:
1. 根据终态和非终态分成两个子集
2. 然后根据子集中读相同元素得到的结果属于哪个集合再分,直到不能分为止
![[Pasted image 20230402151347.png]]
如图,首先我们将其分为{0,1,2}和{3,4,5,6}(终态)
然后我们读入a,0->1,1->3,2->1,发现0,2落在同一个集合,1落在另一个集合,所以吧{0,1,2}分为{1},{0,2},然后又发现读b补一个集合,所以再分,得到结果{1},{0},{2},{3,4,5,6},把同一个集合的合并

# 正则表达式和正规集
## 正规式:
1. ![[Pasted image 20230402151801.png]]
2. ![[Pasted image 20230402151811.png]]
\|表示或,\*表示自己重复n次,·表示自连接
## 正则文法->正则式
用+代替|,=代替->
我们可以得到两个推论:X=rx+t有解X=r\*t
X = Xr+t有解X=tr\*
![[Pasted image 20230402152111.png]]
## 正则式构造有限自动机
![[Pasted image 20230402152219.png]]
![[Pasted image 20230402152232.png]]
