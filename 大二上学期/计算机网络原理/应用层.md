 #应用层 
# 应用层协议原理
在研发应用程序时，不需要写在网络核心设备如路由器或链路层交换机上运行的软件，即使要写， 也不可能。网络核心并不在应用层起作用，仅在较低层起作用。 ![[Pasted image 20221123084225.png]]

# HTTP
## HTTP概况
web应用的应用层是 #超文本传输协议 HTTP，他是web的核心。HTTP由两个程序实现，一个客户端程序和一个服务器端程序。他们运行在不同的端系统中，通过交换HTTP报文进行对话。
Web页面由对象组成的。一个对象只是一个文件，诸如一个HTML文件，一个java小程序，一个视屏片段这样的文件，他们可以使用URL地址寻址。多数web页面包含有一个HTML基本文件及几个引用对象。例如，如果一个web页面包含HTML文本和5个JPEG图形，那么他就有6个对象。每个URL由两部分，：存放对象的服务器主机和对象的路径名。例如URL为http:// www. someSchool. edu/someDepartment/picture. gif,其中的 www. someSchool. edu 就是主机名 / someDepartment/picture, gif 就是路径名。Web服务器实现了HTTP的服务器端用于存储对象，每个对象由URL寻址
HTTP使用TCP作为他的支撑运输协议。HTTP客户端首先发起一个与服务器端的TCP链接。一旦建立连接，该浏览器和服务器进程就可以通过套接字访问TCP。因为TCP可靠传输，所以HTTP并不考虑数据丢失与恢复。
此外，服务器端向客户发送被请求的文件而不储存用户信息。因为HTTP不记录任何客户端信息，所以我们说HTTP是一个 #无状态协议 

## 非持续链接和持续链接
根据每个请求/响应用一个单独的TCP链接发送还是所有的请求和响应用同一个TCP链接发送，我们将其分为 #非持续链接 和 #持续链接 
### 采用非持续链接的HTTP
我们看看在非持续连接情况下，从服务器向客户传送一个Web页面的步骤。假设该页面含有一个HTML基本文件和10个JPEG图形，并且这11个对象位于同一台服务器上。进一步假设该 HTML 文件的 URL 为：http :〃www. someSchool. edu/someDepartment/home, indexo我们看看发生了什么情况：
1） HTTP客户进程在端口号80发起一个到服务器www. someSchool. edu的TCP连接，该端口号是HTTP的默认端口。在客户和服务器上分别有一个套接字与该连接相关联。
2） HTTP客户经它的套接字向该服务器发送一个HTTP请求报文。请求报文中包含了路径名/someDepartment/home. index 
3） HTTP服务器进程经它的套接字接收该请求报文，从其存储器 RAM或磁盘中检索出对象 www. someSchool. edu/someDepartment/home. index,在一个 HTTP 响应报文中封装对象，并通过其套接字向客户发送响应报文。
4） HTTP服务器进程通知TCP断开该TCP连接。（但是直到TCP确认客户已经完整地收到响应报文为止，它才会实际中断连接）
5） HTTP客户接收响应报文，TCP连接关闭。该报文指岀封装的对象是一个HTML文件，客户从响应报文中提取出该文件，检査该HTML文件，得到对10个JPEG图形的引用。
6） 对每个引用的JPEG图形对象重复前4个步骤。
当浏览器收到Web页面后，向用户显示该页面。两个不同的浏览器也许会以不同的方式解释（即向用户显示）该页面。HTTP与客户如何解释一个Web页面毫无关系。HTTP规范 ［RFC 1945］和［RFC2616］）仅定义了在HTTP客户程序与HTTP服务器程序之间的通信协议

对此，我们先定义 #往返时间 RTT，该时间是指一个段分组从客户到服务器然后返回客户所花的时间。包括分组传播时延，排队实验，以及处理时延。现在考虑用户点击超链接的现象。首先是一个TCP链接，客户向服务器发送一个TCP报文段，服务器返回确认和响应。完成前两个部分之后，客户端第三次握手时发送HTTP请求报文，所以总的响应时间就是2个RTT加上传输HTML文件的时间。
![[Pasted image 20221123090521.png]]

### 采用持续链接的HTTP
非持续链接有一些缺点
- 为每一个请求对象建一个全新链接，要分配TCP缓冲区和端口，浪费资源
- 每一个对象经受两倍RTT交付时延，一个用于创建TCP链接，一个用于接收对象
采用持续链接，服务器在响应TCP链接后保持打开，后续的响应额报文能够通过相同的TCP链接传送。

## HTTP报文格式
HTTP报文有两种，请求报文和响应报文
### HTTP响应报文
下面提供了一个典型的HTTP请求报文:
```HTTP
GET /somedir/page.html HTTP/1.1
Host: www someschool•edu
Connection: close
User-agent: Mozilla/5•0
Accept-language: fr

```
这个请求报文第一行叫做 #请求行 ，其后的行叫 #首部行 。请求行有三个字段，包括方法字段，URL字段和HTTP版本字段。
对于首部行，`Host: www someschool•edu`表示对象所在的主机，`User-agent`表示用户所使用的代理（即浏览器），最后language表示想要得到法语版本
对于实体体，使用GET方法时为空，而POST方法时才有实体体。
![[Pasted image 20221123092148.png]]

### HTTP响应报文
```HTTP
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tuer 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html
(data data data data data •••)
```
这个响应报文有三个部分：一个 #初始状态行 ，6个首部行最后是实体体。实体体是报文的主要部分，它包含了请求的对象本身。
状态行由三个字段：协议版本，状态码和相应状态信息。
首部行用close表示发送完报文后关闭连接，Data表示服务区产生并发送报文的时间和日期（并不是最后修改时间）。server表示是一台Apache Web服务器产生的。Last-Modify表示最后修改日期。Content-Length表示他发送对象的字节数，Content-Type表示实体体中对象是HTML文本。
以下是一些状态码信息
• 200 0K 请求成功，信息在返回的响应报文中。
• 301 Moved Permanently 请求的对象已经被永久转移了，新的URL定义在响应报文的Location:首部行中。客户软件将自动获取新的URL
• 400 Bad Request: 一个通用差错代码，指示该请求不能被服务器理解。
• 404 Not Found:被请求的文档不在服务器上。
• 505 HTTP Version Not Supported:服务器不支持请求报文使用的HTTP协议版本。

## 用户与服务器的交互：Cookie
前面提到HTTP服务器无状态的,这简化了服务器的设计.但是我们通常希望能够识别用户,为此,HTTP使用了cookie
cookie技术有4个组件：①在HTTP响应报文中的一个cookie首部
行；②在HTTP请求报文中的一个cookie首部行；③在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理；④位于Web站点的一个后端数据库。
当用户第一次访问某个网页时,将生成一个唯一标识码Set-cookie:1678,接下来用户就需要使用这个cookie来标识自己.他发往主机的每个HTTP报文都会含有以下首部行:Cookie:1678
![[Pasted image 20221123093408.png]]
## Web缓存
#Web缓存器 也叫 #代理服务器 他能代表初始web服务器来满足http请求的网络实体.WEB缓存器有自己的磁盘,存储并保存最近请求过得对象的副本,用户HTTP请求先指向Web缓存器.
举例来说，假设浏览器正在请求对象 http :〃www. someschool. edu/campus, gif,将会发生如下情况：
1）浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求。
2） Web缓存器进行检查，看看本地是否存储了该对象副本。如果有，Web缓存器就向客户浏览器用HTTP响应报文返回该对象。
3） 如果Web缓存器中没有该对象，它就打开一个与该对象的初始服务器（即WWW. someschool. edu）的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求。在收到该请求后，初始服务器向该Web缓存器发送具有该对象的HTTP响应。
4） 当Web缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用HTTP响应报文发送该副本（通过现有的客户浏览器和Web缓存器之间的TCP连接）。
值得注意的是Web缓存器既是服务器又是客户。当它接收浏览器的请求并发回响应时，它是一个服务器。当它向初始服务器发出请求并接收响应时，它是一个客户

使用Web服务器能大幅减少客户请求响应时间及连出的通信量,就不比急于增加带宽,因此降低了费用
如图2.12,我们有一个高速局域网,他的路由器与英特网上的一台路由器通过15Mbps的链路链接.假设对象平均长度为1Mb,每秒15个请求,假设HTTP请求报文小到可以忽略,我们还假设在图2・12中从因特网接入链路一侧的路由器转发HTTP请求报文（在一个IP数据报中）开始，到它收到其响应报文（通常在多个IP数据报中）为止的时间平均为2秒。
响应时间为局域网时延,接入时延和因特网时延
局域网流量强度:15请求/s*1Mb/请求/100Mbps = 0.15
接入链路流量强度:15请求/s*1Mb/请求/15Mbps = 1
这意味着延时将无限大.如果增加带宽,升级为100Mbps,那么总得响应时间大约为2s
![[Pasted image 20221123094258.png]]
现在我们换一个角度.我们安装了一台Web缓存器,假设其命中率大约为0.4,响应时间可以忽略,那么只有0.6的对象进过链路,此时链路流量强度为0.6.此时平均时延为0.4×0.01+0.6×0.201 = 1.2,更廉价效果更好
通过使用内容分发网络（Content Distribution Network, CDN） , Web缓存器正在因特网中发挥着越来越重要的作用。
 ![[Pasted image 20221123094307.png]]
## 条件GET方法
虽然使用高速缓存能够减少响应时间,但是存放在缓存器中的对象可能是旧的.所以,HTTP协议有一种机制,允许缓存器证实他的他徐昂是最新的.这种机制就是 #条件GET 方法,在请求报文中添加一个``if-modifyed-since`` 的首部行就说明他是一个条件GET请求报文.

# 因特网中的电子邮件
图2-14给出了因特网电子邮件系统的总体情况,他有三个部分: #用户代理 #服务器代理 和 #简单邮件传输协议 (即SMTP).
## 邮件发送的过程
从发送方的用户代理开始,传输到发送方的邮件服务器,在传输到接收方的邮件服务器,然后被分发到接收方的邮箱.如果邮件不能正常交付,发送发邮件服务器会在一个报文队列中保持该报文并且尝试重发.如果几天后还是不行,服务器会删除该报文并且警告发送方
![[Pasted image 20221123125030.png]]

## SMTP
SMTP是因特网电子邮件的核心,用于从发送方的邮件服务器发送报文到接收方的邮件服务器.
为了描述 SMTP 的基本操作，我们观察一种常见的情景。假设 Alice 想给 Bob 发送一封简单的 ASCIL 报文。
1) Alice 调用她的邮件代理程序并提供 Boh 的邮件地址（例如 bob@ someschool. edu)，撰写报文，然后指示用户代理发送该报文。
2) Alice 的用户代理把报文发给她的邮件服务器，在那里该报文被放在报文队列中。
3) 运行在 Alice 的邮件服务器上的 SMTP 客户端发现了报文队列中的这个报文，它就创建一个到运行在 Bob 的邮件服务器上的 SMTP 服务器的 TCP 连接。
4) 在经过一些初始 SMTP 握手后，SMTP 客户通过该 TCP 连接发送 Alice 的报文。
5) 在Bob 的邮件服务器上，MTP 的服务器端接收该报文。Bob 的邮件服务器然后将该报文放入 Bob 的邮箱中。
6) 在Bob 方便的时候，他调用用户代理阅读该报文。
![[Pasted image 20221123125817.png]]
通过上述描述,我们可以发现如下现象:SMTP不需要中间邮件服务器转发邮件,这两个TCP直接在二者的邮件服务器链接,不会在某处停留

### 与HTTP对比
这两个协议都是从一台主机向另一台主机传送文件,当进行文件传送时,持续的HTTP和SMTP都是用持续链接.这二者也有不同
1. HTTP是一个 #拉协议 而SMTP基本上是一个 #推协议 
2. SMTP要求每个报文采用7bitASCLL码格式而HTTP不受这种限制
3. HTTP将图形以及文本都封装在自己的HTTP响应报文内,而SMTP则把所有报文对象放在一个报文之中.

### 邮件报文格式
一个典型的报文首部看起来如下：
```http
From: aliceecrepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of 1ife.
```

在报文首部之后，紧接着一个空白行，然后是以 ACSII 格式表示的报文体。

### 邮件访问协议
流行的邮件访问协议有: #第三版邮局协议 即POP3, #因特网邮件访问协议 IMAP以及http
#### POP3
当用户代理（客户）打开了一个到邮件服务器（服务器）端口110 上的 TCP 连接后，POP3 就开始工作了。随着建立 TCP连接，POP3 按照三个阶段进行工作：特许（authorization）、事务处理以及更新。在第一个阶段即特许阶段，用户代理发送（以明文形式）用户名和口令以鉴别用户。在第二个阶段即事务处理阶段，用户代理取回报文；同时在这个阶段用户代理还能进行如下操作，对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。在第三个阶段即更新阶段，它出现在客户发出了 guit 命令之后，目的是结束该 POP3 会话；这时，该邮件服务器删除那些被标记为删除的报文。
但是POP3协议是将邮件下载之后就删除,不能从多个机器访问邮件报文
#### IMAP
为了解决POP3不能在远程主机上访问,IMAP因运而生
IMAP另一个重要特点是他可以允许用户代理后去报文某些部分避免下载过大的邮件





# DNS:因特网的目录服务
主机的标识方法使用他的 #主机名 例如www.edu.com,bjtu.edu这些名字便于记忆,但是主机名几乎没有提供他在因特网中的信息,而且主机也可以使用IP地址标识
## DNS提供的服务
人们习惯于记忆主机名,而路由器喜欢IP,为了折中, #域名系统 DNS应运而生,它的主要任务就是将IP与主机名进行转换.DNS是:1.一个由分层的DNS服务器实现的分布式数据库 2.一个使主机能过查询分布式数据库的应用层协议
主机能够将一个 HTTP 请求报文发送到 Web 服务器 www. someschool edu，该用户主机必须获得 www. someschool. edu 的IP 地址。其做法如下。
1) 同一台用户主机上运行着 DNS 应用的客户端。
2) 浏览器从上述 URL 中抽取出主机名 www. someschool. edu，并将这台主机名传给DNS 应用的客户端。
3) DNS 客户向 DNS 服务器发送一个包含主机名的请求。
4) DNS 客户最终会收到一份回答报文，其中含有对应于该主机名的 IP 地址。
5) 一旦浏览器接收到来自 DNS 的该IP 地址，它能够向位于该 IP 地址80 端口的HTTP 服务器进程发起一个 TCP 连接。
除了主机名与IP转化之外,DNS还提供了
- 主机别名 一个主机有多个别名
- 邮件服务器别名
- 负载分配 繁忙的站点被冗余分布在多台服务器上,每台服务器运行在不同的端系统,有着不同IP,但是DNS能够记录下一个主机的各个ip并且循环响应,这样就降低了负载

DNS是一个分布式,层次数据库,主要有三种类型:根DNS,顶级域DNS(TLD)和权威DNS.根DNS知道顶级域DNS的ip,顶级域知道权威
![[Pasted image 20221123134240.png]]
此外还有本地DNS服务器

我们来看一个简单的例子，假设主机cse. nyu. edu 想知道主机 gaia. cs. umass. edu的IP地址。同时假设纽约大学 NYU）的cse. nyu. edu主机的本地DNS服务器为dns. nyu. edu, 并且 gaia. cs.umass. edu 的权威DNS服务器为dns. umass. eduo如图2 18所示 主机cse. nyu. edu首先向它的本地DNS服务器dns. nyu. edu发送一个DNS查询报文。该查询报文含有被转换的主机名gaia. cs. umass. eduo本地DNS服务器将该报文转发到根DNS服务器。该根DNS服务器注意到其edu前缀并向本地DNS服务器返回负责edu的TLD的IP地址列表。该本地DNS服务器则再次向这些TLD服务器之一发送查询报文。该TLD服务器注意到umass. edu前缀，并用权威DNS服务器的IP地址进行响应，该权威DNS服务器是负责马萨诸塞大学的dns. umass. eduo最后，本地DNS服务器直接向dns.umass. edu重发查询报文,dns. umass. edu用gaia. cs. umass. edu的IP地址进行响应。注意到在本例中，为了获得一台主机名的映射，共发送了 8份DNS报文：4份查询报文和4份回答报文！(总的来说就是先访问主机,主机没有访问根,再访问顶级域,再访问权威,再访问指定IP)
![[Pasted image 20221123134338.png]]
![[Pasted image 20221123134824.png]]
此外,本地储存器还能储存DNS的映射一段时间,减少了网络压力.
![[Pasted image 20221123135628.png]]

# P2P下崽器
在客户-服务器文件分发中,该服务器必须向每个队登发发送一个副本,使得服务器接受极大的负担与带宽
在p2p协议中,每个对等发都能像任何其他对等方发送文件的任何部分
![[Pasted image 20221123135850.png]]
## 比特洪流
BitTorrent是一种用于文件分发的流行P2P协议 ,在任何时间,每个对等发将具有来自文件的块的子集,并且不同对等放有不同子集,用户周期询问每个对等方具有的块列表,因此知道他的邻居有哪些快.我们采用 #最稀缺优先 原则,优先下载他没有的中邻居有的最少得快,这样,最少的快得到更迅速的转发,能够均衡每个块的数量.其次,用户能够根据以最高速率向他提供数据的邻居给出优先权.正在向Bob发送数据，她可能成为Bob前4位上载者之一，这样的话Bob将开始向Alice发送数据。如果Bob向Alice发送数据的速率足够高，Bob接下来也能成为Alice的前4位上载者。换言之,每过30秒Alice将随机地选择一名新的对换伴侣并开始与那位伴侣进行对换。如果这两名对等方都满足此对换，它们将对方放入其前4位列表中并继续与对方进行对换，直到该对等方之一发现了一个更好的伴侣为止。(一报还一报)
# 内容分发网
//好像不是很重要