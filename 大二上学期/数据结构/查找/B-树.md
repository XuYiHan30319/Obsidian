# 定义
M阶B-树的每个节点有$\lceil M/2\rceil$-1--M-1个<font color="#ff0000">关键字</font>,根节点的度为2--m,所有的叶子结点都在同一层,每个非叶子结点都包含了许多信息,每个节点有1-m-1
2阶B-树是完全二叉树,m阶b-树具有k个子树的非叶子结点具有k-1个关键字
![[Pasted image 20221207081254.png]]![[Pasted image 20221207081254.png]]
3阶B-树或者4阶
![[Pasted image 20221207081346.png]]
# B-树的插入
![[Pasted image 20221207081908.png]]
插入25,该节点的次数超过了4,所以我们需要多出一层
![[Pasted image 20221207081939.png]]
插入28
![[Pasted image 20221207082029.png]]
又超过了4,所以将节点上移
![[Pasted image 20221207082051.png]]
![[Pasted image 20221207082145.png]]
......
插入45
![[Pasted image 20221207082248.png]]
上移
![[Pasted image 20221207082314.png]]
上层溢出,再次上移
![[Pasted image 20221207082342.png]]

# B-树的删除
我们将b-树的删除分为两种
- 第一种是删除的节点很富有,删除它不会导致节点过少
- 第二种是节点不富有,需要问别的节点借
![[Pasted image 20221207083145.png]]
![[Pasted image 20221207083245.png]]
2. 如果该叶子节点是“不富有”的，那该怎么处理呢？这又可以分为2中情况讨论

A. 兄弟节点是“富有”的（我没钱，但我哥有钱 ?）这种情况我们只需要从父节点中要一个key，然后由兄弟节点补一个key到父节点。

比如说我们现在还想将 180 删除，由于 180 所在的节点是“不富有”的，但右兄弟节点是“富有”的，所以我们将父节点中的 230 要下来，然后兄弟节点在补一个 240 到父节点，看下图：
![[Pasted image 20221207083346.png]]
要是兄弟节点也不够富有,那只能看爹了
现在还想 删掉 50 ，会怎样呢？看下图：
如果父节点也不够富有,那么树的高度就要-1了
![](https://pic4.zhimg.com/80/v2-d666d85dcc12ef42ecb4defe12e4347b_1440w.webp)
B2: 父节点“富有”（我爹是马云，我怕啥?）兄弟虽然没钱但我是个富二代，这也比较好办，从父节点要一个下来，然后兄弟合并即可。比如我现在还想删除 140，看图：
![](https://pic4.zhimg.com/80/v2-568cda257d56a1b1258ffa93343aff13_1440w.webp)

父节点补个 170 然后和右边的兄弟合并即可。



# B-树的查找
从根节点出发,沿着指针搜索节点和在节点内进行顺序查找两个过程交替进行,如果查找成功,返回只想被查关键字所在节点的指针和关键字在节点的位置,如果不成功,返回插入位置
```c++
typedef struct{
BTNode *pt;
int i;
int tag;
} Result;
	
Result SearBTree(BTree T,KeyType K){
	p = T;q=nullptr;found = false;i=0;
	while(p && !found){
		n = p->keynum;i = Search(p.k);
		//在p节点中查找i
		if(i>0&&p->key[i]==k) found = true;
		else {q = p; p = p->ptr[i];}
	}
	if(found) return (p.i.1);//p为目前节点,是找到的位置
	else return (q,i,0);//q是上一个节点,为要插入的位置
}
```

在一棵有n个关键字的B-树的查找次数不超过 $log\lceil m/2\rceil((N+1)/2)+1$

# B+树
1. 每个叶子结点中含有n个关键字和n个指向记录的指针
2. 每个非叶子结点可以看成索引部分,其中的关键字Ki即为其相应指针Ai所指子树中关键字的最大值
3. 有两个指针,一个指向根节点,另一个头指针指向含有最小关键字的叶子结点
4. 所有的叶子结点包含了全部的关键字信息,以及指向韩这些关键字记录的指针,都在同一层,所有的叶子结点彼此连接乘一个有序链表,每个叶子结点中关键字的个数都在$\lceil m/2\rceil$ 和m之间
![[Pasted image 20221207085804.png]]