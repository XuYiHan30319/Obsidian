# 规范化
## 函数依赖
设R(u)是属性集U上的关系模式,X,Y是U的子集,如果对于R(U)的一个可能关系r,r中不可能存在两个元组在x上的属性值相等,而在Y的属性值不等,则称为X函数确定Y,记作X→Y
比如当一个学校没有人重名的时候,姓名可以唯一确定年龄,即姓名→年龄
![[Pasted image 20221208095347.png]]
![[Pasted image 20221208095405.png]]
例6.1中(Sno, Cno) 上 Grade 是完全函数依赖，(Sno, Cno)一sdept 是部分函数依赖，因为 Sno—-Sdept 成立，而 Sno 是(Sno,Cno)的真子集。

码是关系模式中的一个重要概念
定义6.4 设区为R<U,F>中的属性或属性组合，若K上U，则K为R的候选码(candidatekey)。注意 U是完全函数依赖于人，而不是部分函数依赖于K。如果 U部分函数依赖于K，即K一U，则K称为超码（Surpkey)。候选码是最小的超码，即K的任意一个真子集都不是候选码。若候选码多于一个，则选定其中的一个为主码（primary key)。包含在任何一个候选码中的属性称为主属性 (prime attribute)；不包含在任何候选码中的属性称为非主属性 (nonprime attribute）或非码属性(non-key attribute )。最简单的情况，单个属性是码：最极端的情况，整个属性组是码，称为全码（all-key)。

# 范式
## 2NF
若R∈1NF,且每一个非主属性完全函数依赖于任何一个候选码,则R∈2NF.
在这个例子中,码是(sno,cno),但是我们能够看到sdept和sloc指依赖于sno,所以是部分函数依赖,不符合第二范式![[Pasted image 20221208100633.png]]

## 3NF
![[Pasted image 20221208100850.png]]
,比如在上一个例子里面,sno->sdept,sdept->sloc,而且sno是吗,sdept和sloc都是非主属性,这产生了传递函数依赖,

## BCNF
![[Pasted image 20221208101345.png]]
由 BCNF 的定义可以得到结论，一个满足 BCNF 的关系模式有：
- 所有非主属性对每一个码都是完全函数依赖。
- 所有主属性对每一个不包含它的码也是完全两数依赖。
- 没有任何属性完全函数依赖于非码的任何一组属性。
