# 并发控制
多用户共享系统中,多个用户同时对一个数据操作.并发是指多个事务利用分时技术,在同一cpu上分段执行
避免并发操作造成数据不一致,DBMS就要用正确的方式调度并发操作,使一个用户事务的执行不搜其他影响

# 不并发操作的问题
## 丢失更新的问题：
![[Pasted image 20221126141900.png]]卖了两张票但是只是少了一张![[Pasted image 20221126142004.png]]

## 不一致分析问题（即读了过时的数据）----不可重复读；
![[Pasted image 20221126142101.png]]
![[Pasted image 20221126142244.png]]

## “脏数据”的读出。
在数据库技术中，未提交的随后又被撤消的数据为“脏数据".
![[Pasted image 20221126142324.png]]
![[Pasted image 20221126142444.png]]

# 封锁机制
读之前先封锁A,这样其他就不能读取和修改A,修改并写回A知乎解除A的封锁
常用的封锁有两种：
1. 排它型封锁(x封锁，排他锁或称X锁）一写锁
2. 共享型封锁(S封锁，共享锁或称S锁）一读锁

## 排它锁
若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。保证其他事务在T释放A上的锁之前不能再读取和修改A。

## 共享锁-S锁
若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。保证其他事务可以读A,但在T释放A上的S锁之前不能对A做任何修改。

## 相容矩阵
![[Pasted image 20221126143442.png]]
# X封锁的规则
![[Pasted image 20221126143632.png]]
如果没有得到,那么等到获得X封锁再进行.简记为：先锁X，再执行，取不到，就等待。使用PX协议就可以解决丢失更新的问题
但是RX并不能彻底解决,如果后面回滚了,就会失效了
![[Pasted image 20221126144109.png]]
修改事务一直到事务彻底结束,才会释放X锁

# S封锁的规则
![[Pasted image 20221126144257.png]]
PSC->将s🔐保持到事务终点,解决不可重复读的问题
![[Pasted image 20221126145123.png]]

# 解除死锁的方法
## 预防死锁
![[Pasted image 20221126151219.png]]
## 诊断解除死锁
![[Pasted image 20221126151448.png]]
![[Pasted image 20221126151614.png]]
可以用拓扑排序来确定有没有环路

事务的执行次序称为调度。对多个事务处理有两种方法：
1.串行调度
事务的依次执行称为串行调度。
2. 并发调度
利用分时的方法，同时处理多个事务，称为事务的并发调度。
![[Pasted image 20221126152537.png]]
![[Pasted image 20221126152734.png]]
![[Pasted image 20221126152859.png]]
![[Pasted image 20221126154053.png]]
![[Pasted image 20221126154111.png]]
![[Pasted image 20221126154345.png]]
