事务可以一个一个的串行执行,即每一个时刻只有一个事务运行
但是实际上时事务交替运行的,多个事务同时运行叫做同时并发![[Pasted image 20221209213348.png]]
并发控制保证了事务的隔离性和一致性
并发操作带来的问题有如下三种
## 不可重复读
不可重复读指的是第一个事务读了数据之后,另一个事物更新,使得前一个事务再读的时候就不一样了,一般包含三种情况
（1）事务T 读取某一数据后，事务 T对其进行了修改，当事务 Ti再次读该数据时，
得到与前一次不同的值。例如在图11.2(b)中，T读取 B-100 进行运算，T.读取同一数据 B,对其进行修改后将 B-200 写回数据库。T为了对读取值校对重读 B，B已为200，与第一次读取值不一致。
（2）事务T按一定条件从数据库中读取了某些数据记录后，事务T.删除了其中部分记录，当工再次按相同条件读取数据时，发现某些记录神秘地消失了。
（3）事务工按一定条件从数据库中读取某些数据记录后，事务T：插入了一些记录，当工再次按相同条件读取数据时，发现多了一些记录。后两种不可重复读有时也称为幻影（phantom row）现象。
## 修改丢失
两个事物t1和t2同时读入同一数据并修改,t2的提交结果破坏了t1的提交结果,导致t1的修改丢失
## 读脏数据
读脏数据就是指t1修改了某一数据并且存入了磁盘,t2使用了该数据,但是t1撤销了这次修改,这是t2独到的就是脏数据
![[Pasted image 20221209214752.png]]

# 封锁
封锁是实现并发控制的一个非常重要的技术
基本锁类型有两种,排它锁(写锁  X)和共享锁(读锁  S)
- 排它锁 如果对数据对象添加了X锁,只允许该事物读取和修改A,其他事物都不能对A添加任何类型的锁,直到A释放为止
- 共享锁 若事务T对数据对象添加S锁,这样就保证事务T可以读A但不能修改,其他事务也只能添加S锁
![[Pasted image 20221209220107.png]]

# 封锁协议
## 一级封锁协议
在修改数据前添加x锁
在一级封锁协议的情况下,读数据是不需要加锁,所以会导致读脏数据
## 二级封锁协议
在一级协议的基础上添加了读数据前必须添加s锁,但是由于读完就释放,所以不能保证可重复读
## 三级封锁协议
读数据前必须添加s锁,直到事务结束释放
![[Pasted image 20221209221001.png]]

# 并发调度的可串行性
多个事务的并发执行是正确的,当且仅当按某一顺序串行的执行结果相同,这种调度策略被称为可串行化调度
可串行性是并发事务的正确调度的准则
下面是可串行化调度的充分条件
冲突操作是指对于同一个数据的读写操作![[Pasted image 20221209222038.png]]
不同事务的冲突操作和同一事物的俩操作是不能交换的.如果一个调度室冲突可串行化的,那么一定是可串行化的![[Pasted image 20221209222202.png]]
